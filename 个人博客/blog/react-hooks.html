<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Hooks 最佳实践指南 - 我的个人博客</title>
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="../index.html"><h2>我的博客</h2></a>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="../index.html" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="../index.html#about" class="nav-link">关于我</a>
                </li>
                <li class="nav-item">
                    <a href="../projects.html" class="nav-link">项目展示</a>
                </li>
                <li class="nav-item">
                    <a href="../blog.html" class="nav-link active">技术分享</a>
                </li>
                <li class="nav-item">
                    <a href="../index.html#contact" class="nav-link">联系方式</a>
                </li>
            </ul>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <!-- 文章内容 -->
    <article class="blog-detail">
        <div class="container">
            <!-- 返回按钮 -->
            <div class="back-button">
                <a href="../blog.html" class="btn btn-outline">
                    <i class="fas fa-arrow-left"></i> 返回技术分享
                </a>
            </div>

            <!-- 文章头部 -->
            <header class="article-header">
                <div class="article-category">前端开发</div>
                <h1>React Hooks 最佳实践指南</h1>
                <div class="article-meta">
                    <span class="article-date">
                        <i class="fas fa-calendar-alt"></i>
                        2024年1月15日
                    </span>
                    <span class="article-reading-time">
                        <i class="fas fa-clock"></i>
                        8分钟阅读
                    </span>
                    <span class="article-views">
                        <i class="fas fa-eye"></i>
                        1,234 次阅读
                    </span>
                </div>
                <div class="article-tags">
                    <span class="article-tag">React</span>
                    <span class="article-tag">Hooks</span>
                    <span class="article-tag">JavaScript</span>
                    <span class="article-tag">前端开发</span>
                </div>
            </header>

            <!-- 文章封面 -->
            <div class="article-cover">
                <img src="../assets/images/blog1.jpg" alt="React Hooks 最佳实践指南">
            </div>

            <!-- 文章内容 -->
            <div class="article-content">
                <h2>什么是React Hooks？</h2>
                <p>React Hooks是React 16.8引入的新特性，它让你在不编写class组件的情况下使用state和其他React特性。Hooks的出现彻底改变了React组件的编写方式，让函数组件拥有了类组件的所有能力。</p>

                <h3>Hooks的优势</h3>
                <ul>
                    <li><strong>逻辑复用更简单</strong>：通过自定义Hooks可以轻松复用状态逻辑</li>
                    <li><strong>组件更简洁</strong>：避免了class组件的复杂性和this绑定问题</li>
                    <li><strong>更好的性能</strong>：函数组件配合React.memo可以获得更好的性能</li>
                    <li><strong>更容易测试</strong>：函数组件更容易进行单元测试</li>
                </ul>

                <h2>常用Hooks详解</h2>

                <h3>1. useState - 状态管理</h3>
                <p>useState是最基本的Hook，用于在函数组件中添加state。</p>
                <pre><code>import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;你点击了 {count} 次&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        点击我
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>2. useEffect - 副作用处理</h3>
                <p>useEffect用于处理副作用，如API调用、订阅、DOM操作等。</p>
                <pre><code>import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    async function fetchUser() {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('获取用户信息失败:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]); // 依赖数组

  if (loading) return &lt;div&gt;加载中...&lt;/div&gt;;
  if (!user) return &lt;div&gt;用户不存在&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>3. useContext - 上下文管理</h3>
                <p>useContext用于在组件树中共享数据，避免props drilling。</p>
                <pre><code>import React, { createContext, useContext, useState } from 'react';

// 创建上下文
const ThemeContext = createContext();

// 提供者组件
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// 使用上下文的组件
function ThemeButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    &lt;button 
      onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}
      style={{ 
        background: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    &gt;
      切换到 {theme === 'light' ? '暗色' : '亮色'} 主题
    &lt;/button&gt;
  );
}</code></pre>

                <h2>最佳实践</h2>

                <h3>1. 遵循Hooks规则</h3>
                <ul>
                    <li><strong>只在最顶层调用Hooks</strong>：不要在循环、条件或嵌套函数中调用Hooks</li>
                    <li><strong>只在React函数中调用Hooks</strong>：在React函数组件或自定义Hooks中调用</li>
                </ul>

                <h3>2. 正确使用依赖数组</h3>
                <p>useEffect的依赖数组要包含所有在effect中使用的值：</p>
                <pre><code>// ❌ 错误：缺少依赖
useEffect(() =&gt; {
  fetchData(userId);
}, []); // 缺少userId依赖

// ✅ 正确：包含所有依赖
useEffect(() =&gt; {
  fetchData(userId);
}, [userId]);</code></pre>

                <h3>3. 自定义Hooks提取逻辑</h3>
                <p>将复杂的逻辑提取到自定义Hooks中：</p>
                <pre><code>// 自定义Hook
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) =&gt; {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('保存到localStorage失败:', error);
    }
  };

  return [storedValue, setValue];
}

// 使用自定义Hook
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    &lt;button onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}&gt;
      当前主题: {theme}
    &lt;/button&gt;
  );
}</code></pre>

                <h2>常见陷阱与解决方案</h2>

                <h3>1. 无限循环的useEffect</h3>
                <p>当依赖数组中包含对象或数组时，可能导致无限循环：</p>
                <pre><code>// ❌ 可能导致无限循环
const [user, setUser] = useState({ name: '', age: 0 });

useEffect(() =&gt; {
  // 每次渲染都会执行，因为user是新的对象引用
  console.log('用户信息更新:', user);
}, [user]);

// ✅ 解决方案：使用具体的属性作为依赖
useEffect(() =&gt; {
  console.log('用户信息更新:', user);
}, [user.name, user.age]);</code></pre>

                <h3>2. 闭包陷阱</h3>
                <p>在useEffect中访问state可能会遇到闭包陷阱：</p>
                <pre><code>// ❌ 闭包陷阱
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      setCount(count + 1); // count始终是0
    }, 1000);

    return () =&gt; clearInterval(timer);
  }, []); // 空依赖数组

  return &lt;div&gt;{count}&lt;/div&gt;;
}

// ✅ 解决方案：使用函数式更新
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      setCount(prevCount =&gt; prevCount + 1); // 使用前一个值
    }, 1000);

    return () =&gt; clearInterval(timer);
  }, []);

  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <h2>性能优化技巧</h2>

                <h3>1. 使用useMemo优化计算</h3>
                <pre><code>import React, { useMemo } from 'react';

function ExpensiveComponent({ items, filter }) {
  const filteredItems = useMemo(() =&gt; {
    return items.filter(item =&gt; item.includes(filter));
  }, [items, filter]);

  return (
    &lt;ul&gt;
      {filteredItems.map(item =&gt; (
        &lt;li key={item}&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>2. 使用useCallback优化函数</h3>
                <pre><code>import React, { useCallback, useState } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // 使用useCallback避免子组件不必要的重渲染
  const handleClick = useCallback(() =&gt; {
    setCount(prev =&gt; prev + 1);
  }, []);

  return (
    &lt;div&gt;
      &lt;input 
        value={name} 
        onChange={(e) =&gt; setName(e.target.value)} 
      /&gt;
      &lt;Child onClick={handleClick} /&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h2>总结</h2>
                <p>React Hooks是现代React开发的核心特性，掌握Hooks的使用可以让你写出更简洁、更易维护的React代码。记住以下要点：</p>
                <ul>
                    <li>遵循Hooks使用规则</li>
                    <li>正确设置依赖数组</li>
                    <li>善用自定义Hooks提取逻辑</li>
                    <li>注意性能优化</li>
                    <li>避免常见陷阱</li>
                </ul>
                <p>希望这篇文章能帮助你更好地理解和使用React Hooks。如果你有任何问题或建议，欢迎在评论区留言讨论！</p>
            </div>

            <!-- 文章底部 -->
            <footer class="article-footer">
                <div class="article-actions">
                    <button class="btn btn-primary">
                        <i class="fas fa-heart"></i> 点赞 (89)
                    </button>
                    <button class="btn btn-secondary">
                        <i class="fas fa-share"></i> 分享
                    </button>
                    <button class="btn btn-outline">
                        <i class="fas fa-bookmark"></i> 收藏
                    </button>
                </div>
                
                <div class="article-navigation">
                    <a href="#" class="nav-prev">
                        <i class="fas fa-chevron-left"></i>
                        <span>上一篇：JavaScript异步编程详解</span>
                    </a>
                    <a href="#" class="nav-next">
                        <span>下一篇：Vue 3 Composition API 入门</span>
                        <i class="fas fa-chevron-right"></i>
                    </a>
                </div>
            </footer>
        </div>
    </article>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 我的个人博客. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>